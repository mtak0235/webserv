CONTENT_LENGTH=0
CONTENT_TYPE=
GATEWAY_INTERFACE=CGI/1.1
PATH_INFO=/test_cgi/
PATH_TRANSLATED=/test_cgi/
QUERY_STRING=
REDIRECT_STATUS=200
REQUEST_METHOD=GET
SCRIPT_FILENAME=./www/test_cgi/
SERVER_PROTOCOL=HTTP/1.1
SERVER_PORT=8081

pid_t		pid;
	int			fdIn[2];//cgi  쪽으로 데이터를 흘러가게 하는 스트림.
	int			fdOut[2];//cgi쪽에서 서버로 보내는 스트림.
	std::string	content;
	std::string	method = this->getEnv("REQUEST_METHOD");

	if (pipe(fdIn) == SYSCALL_ERR || pipe(fdOut) == SYSCALL_ERR)
		throw CgiError();

	// Send variables to the standard input of the program
	if (write(fdIn[FD_OUT], this->_request->getContent().c_str(), this->_request->getContent().size()) < 0)
		throw CgiError();

	this->setCgiStep(CGI_EXECUTE_STATUS);

	// time_t beginTime = time(NULL);
	if ((pid = fork()) == SYSCALL_ERR)
		throw CgiError();
	else if (pid == 0)
	{
		// Modify standard input and output
		close(fdIn[FD_OUT]);
		if (dup2(fdIn[FD_IN], STDIN_FILENO) == SYSCALL_ERR)
			exit(EXIT_FAILURE);
		close(fdIn[FD_IN]); 

		close(fdOut[FD_IN]);//fd0ut[0] 읽기 전용
		if (dup2(fdOut[FD_OUT], STDOUT_FILENO) == SYSCALL_ERR)//표준 출력
			exit(EXIT_FAILURE);
		close(fdOut[FD_OUT]);
		
		// Execute the cgi program on the file
		execve(this->_program.c_str(), NULL, this->_env);//////////////////////////////////////////////////
		exit(EXIT_FAILURE);
	}
	
	close(fdOut[FD_OUT]);
	close(fdIn[FD_IN]);
	close(fdIn[FD_OUT]);
	
	_cgiFd = fdOut[FD_IN];

	if (fcntl(_cgiFd, F_SETFL, O_NONBLOCK))
		warnMsg("set get output non blocking failed");